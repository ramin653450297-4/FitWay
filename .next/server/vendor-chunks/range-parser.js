"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/range-parser";
exports.ids = ["vendor-chunks/range-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/range-parser/index.js":
/*!********************************************!*\
  !*** ./node_modules/range-parser/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("/*!\n * range-parser\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = rangeParser\n\n/**\n * Parse \"Range\" header `str` relative to the given file `size`.\n *\n * @param {Number} size\n * @param {String} str\n * @param {Object} [options]\n * @return {Array}\n * @public\n */\n\nfunction rangeParser (size, str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string')\n  }\n\n  var index = str.indexOf('=')\n\n  if (index === -1) {\n    return -2\n  }\n\n  // split the range string\n  var arr = str.slice(index + 1).split(',')\n  var ranges = []\n\n  // add ranges type\n  ranges.type = str.slice(0, index)\n\n  // parse all ranges\n  for (var i = 0; i < arr.length; i++) {\n    var range = arr[i].split('-')\n    var start = parseInt(range[0], 10)\n    var end = parseInt(range[1], 10)\n\n    // -nnn\n    if (isNaN(start)) {\n      start = size - end\n      end = size - 1\n    // nnn-\n    } else if (isNaN(end)) {\n      end = size - 1\n    }\n\n    // limit last-byte-pos to current length\n    if (end > size - 1) {\n      end = size - 1\n    }\n\n    // invalid or unsatisifiable\n    if (isNaN(start) || isNaN(end) || start > end || start < 0) {\n      continue\n    }\n\n    // add range\n    ranges.push({\n      start: start,\n      end: end\n    })\n  }\n\n  if (ranges.length < 1) {\n    // unsatisifiable\n    return -1\n  }\n\n  return options && options.combine\n    ? combineRanges(ranges)\n    : ranges\n}\n\n/**\n * Combine overlapping & adjacent ranges.\n * @private\n */\n\nfunction combineRanges (ranges) {\n  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)\n\n  for (var j = 0, i = 1; i < ordered.length; i++) {\n    var range = ordered[i]\n    var current = ordered[j]\n\n    if (range.start > current.end + 1) {\n      // next range\n      ordered[++j] = range\n    } else if (range.end > current.end) {\n      // extend range\n      current.end = range.end\n      current.index = Math.min(current.index, range.index)\n    }\n  }\n\n  // trim ordered array\n  ordered.length = j + 1\n\n  // generate combined range\n  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)\n\n  // copy ranges type\n  combined.type = ranges.type\n\n  return combined\n}\n\n/**\n * Map function to add index value to ranges.\n * @private\n */\n\nfunction mapWithIndex (range, index) {\n  return {\n    start: range.start,\n    end: range.end,\n    index: index\n  }\n}\n\n/**\n * Map function to remove index value from ranges.\n * @private\n */\n\nfunction mapWithoutIndex (range) {\n  return {\n    start: range.start,\n    end: range.end\n  }\n}\n\n/**\n * Sort function to sort ranges by index.\n * @private\n */\n\nfunction sortByRangeIndex (a, b) {\n  return a.index - b.index\n}\n\n/**\n * Sort function to sort ranges by start position.\n * @private\n */\n\nfunction sortByRangeStart (a, b) {\n  return a.start - b.start\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmFuZ2UtcGFyc2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3VzZXJzLy4vbm9kZV9tb2R1bGVzL3JhbmdlLXBhcnNlci9pbmRleC5qcz9hZWFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogcmFuZ2UtcGFyc2VyXG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQoYykgMjAxNS0yMDE2IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmdlUGFyc2VyXG5cbi8qKlxuICogUGFyc2UgXCJSYW5nZVwiIGhlYWRlciBgc3RyYCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gZmlsZSBgc2l6ZWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNpemVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHJhbmdlUGFyc2VyIChzaXplLCBzdHIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyIG11c3QgYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2YoJz0nKVxuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gLTJcbiAgfVxuXG4gIC8vIHNwbGl0IHRoZSByYW5nZSBzdHJpbmdcbiAgdmFyIGFyciA9IHN0ci5zbGljZShpbmRleCArIDEpLnNwbGl0KCcsJylcbiAgdmFyIHJhbmdlcyA9IFtdXG5cbiAgLy8gYWRkIHJhbmdlcyB0eXBlXG4gIHJhbmdlcy50eXBlID0gc3RyLnNsaWNlKDAsIGluZGV4KVxuXG4gIC8vIHBhcnNlIGFsbCByYW5nZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBhcnJbaV0uc3BsaXQoJy0nKVxuICAgIHZhciBzdGFydCA9IHBhcnNlSW50KHJhbmdlWzBdLCAxMClcbiAgICB2YXIgZW5kID0gcGFyc2VJbnQocmFuZ2VbMV0sIDEwKVxuXG4gICAgLy8gLW5ublxuICAgIGlmIChpc05hTihzdGFydCkpIHtcbiAgICAgIHN0YXJ0ID0gc2l6ZSAtIGVuZFxuICAgICAgZW5kID0gc2l6ZSAtIDFcbiAgICAvLyBubm4tXG4gICAgfSBlbHNlIGlmIChpc05hTihlbmQpKSB7XG4gICAgICBlbmQgPSBzaXplIC0gMVxuICAgIH1cblxuICAgIC8vIGxpbWl0IGxhc3QtYnl0ZS1wb3MgdG8gY3VycmVudCBsZW5ndGhcbiAgICBpZiAoZW5kID4gc2l6ZSAtIDEpIHtcbiAgICAgIGVuZCA9IHNpemUgLSAxXG4gICAgfVxuXG4gICAgLy8gaW52YWxpZCBvciB1bnNhdGlzaWZpYWJsZVxuICAgIGlmIChpc05hTihzdGFydCkgfHwgaXNOYU4oZW5kKSB8fCBzdGFydCA+IGVuZCB8fCBzdGFydCA8IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gYWRkIHJhbmdlXG4gICAgcmFuZ2VzLnB1c2goe1xuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBlbmRcbiAgICB9KVxuICB9XG5cbiAgaWYgKHJhbmdlcy5sZW5ndGggPCAxKSB7XG4gICAgLy8gdW5zYXRpc2lmaWFibGVcbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuY29tYmluZVxuICAgID8gY29tYmluZVJhbmdlcyhyYW5nZXMpXG4gICAgOiByYW5nZXNcbn1cblxuLyoqXG4gKiBDb21iaW5lIG92ZXJsYXBwaW5nICYgYWRqYWNlbnQgcmFuZ2VzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb21iaW5lUmFuZ2VzIChyYW5nZXMpIHtcbiAgdmFyIG9yZGVyZWQgPSByYW5nZXMubWFwKG1hcFdpdGhJbmRleCkuc29ydChzb3J0QnlSYW5nZVN0YXJ0KVxuXG4gIGZvciAodmFyIGogPSAwLCBpID0gMTsgaSA8IG9yZGVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBvcmRlcmVkW2ldXG4gICAgdmFyIGN1cnJlbnQgPSBvcmRlcmVkW2pdXG5cbiAgICBpZiAocmFuZ2Uuc3RhcnQgPiBjdXJyZW50LmVuZCArIDEpIHtcbiAgICAgIC8vIG5leHQgcmFuZ2VcbiAgICAgIG9yZGVyZWRbKytqXSA9IHJhbmdlXG4gICAgfSBlbHNlIGlmIChyYW5nZS5lbmQgPiBjdXJyZW50LmVuZCkge1xuICAgICAgLy8gZXh0ZW5kIHJhbmdlXG4gICAgICBjdXJyZW50LmVuZCA9IHJhbmdlLmVuZFxuICAgICAgY3VycmVudC5pbmRleCA9IE1hdGgubWluKGN1cnJlbnQuaW5kZXgsIHJhbmdlLmluZGV4KVxuICAgIH1cbiAgfVxuXG4gIC8vIHRyaW0gb3JkZXJlZCBhcnJheVxuICBvcmRlcmVkLmxlbmd0aCA9IGogKyAxXG5cbiAgLy8gZ2VuZXJhdGUgY29tYmluZWQgcmFuZ2VcbiAgdmFyIGNvbWJpbmVkID0gb3JkZXJlZC5zb3J0KHNvcnRCeVJhbmdlSW5kZXgpLm1hcChtYXBXaXRob3V0SW5kZXgpXG5cbiAgLy8gY29weSByYW5nZXMgdHlwZVxuICBjb21iaW5lZC50eXBlID0gcmFuZ2VzLnR5cGVcblxuICByZXR1cm4gY29tYmluZWRcbn1cblxuLyoqXG4gKiBNYXAgZnVuY3Rpb24gdG8gYWRkIGluZGV4IHZhbHVlIHRvIHJhbmdlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWFwV2l0aEluZGV4IChyYW5nZSwgaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcmFuZ2Uuc3RhcnQsXG4gICAgZW5kOiByYW5nZS5lbmQsXG4gICAgaW5kZXg6IGluZGV4XG4gIH1cbn1cblxuLyoqXG4gKiBNYXAgZnVuY3Rpb24gdG8gcmVtb3ZlIGluZGV4IHZhbHVlIGZyb20gcmFuZ2VzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtYXBXaXRob3V0SW5kZXggKHJhbmdlKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJhbmdlLnN0YXJ0LFxuICAgIGVuZDogcmFuZ2UuZW5kXG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IGZ1bmN0aW9uIHRvIHNvcnQgcmFuZ2VzIGJ5IGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzb3J0QnlSYW5nZUluZGV4IChhLCBiKSB7XG4gIHJldHVybiBhLmluZGV4IC0gYi5pbmRleFxufVxuXG4vKipcbiAqIFNvcnQgZnVuY3Rpb24gdG8gc29ydCByYW5nZXMgYnkgc3RhcnQgcG9zaXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNvcnRCeVJhbmdlU3RhcnQgKGEsIGIpIHtcbiAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/range-parser/index.js\n");

/***/ })

};
;